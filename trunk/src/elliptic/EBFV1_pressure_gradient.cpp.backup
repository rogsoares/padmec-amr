#include "EBFV1_elliptic.h"

namespace PRS{

// calculates nodal pressure gradients for domain dom
double EBFV1_elliptic::pressureGradient(){
	double start = MPI_Wtime();
	SIter_const dom=pSimPar->setDomain_begin();
	for (;dom!=pSimPar->setDomain_end();dom++){
		pressureGradient(*dom,pGCData->getMeshDim());
	}
	//throw 1;
	double end = MPI_Wtime();
	return end-start;
}

// calculates nodal pressure gradients for domain dom
int EBFV1_elliptic::pressureGradient(int dom, int dim){
//double EBFV1_elliptic::pressureGradient(){

#ifdef _SEEKFORBUGS_
	bool check1 = false;
	bool check2 = false;
#endif

	int i;
	//int dim = 3;
	int dom_counter = 0;
	pEntity node, edge, face;
	dblarray Cij(dim,.0), Dij(dim,.0);
	dblarray pw_grad_I(dim,.0), pw_grad_J(dim,.0),  pw_grad_K(dim,.0);
//	double pw_grad_I[3], pw_grad_J[3],  pw_grad_K[3];
	double pressure_I, pressure_J, pressure_K;

	int ID_I,ID_J;

	int k = 0;
	int nedges = M_numEdges(theMesh);

//	SIter_const dom=pSimPar->setDomain_begin();
//	for (;dom!=pSimPar->setDomain_end();dom++){


		// before any calculation, reset all previous values
		resetPressureGrad(dom_counter,dim);

		// loop over all edges
		// =========================================================================
		EIter eit = M_edgeIter(theMesh);
		while ( (edge = EIter_next(eit)) ){
			if ( pGCData->edgeBelongToDomain(edge,dom) ){

				// get nodes I and J
				pEntity I = (pVertex)edge->get(0,0);
				pEntity J = (pVertex)edge->get(0,1);

				ID_I = EN_id(I);
				ID_J = EN_id(J);
				int row_I = pMData->getLocalNodeIDNumbering(ID_I);
				int row_J = pMData->getLocalNodeIDNumbering(ID_J);

				// todo: colocar este codigo em algum luar de forma que so seja feito uma unica vez.
				if (EN_id(edge->get(0,0)) > EN_id(edge->get(0,1))){
					std::swap(I,J);
				}

				// get Cij vector (normal to control volume surface)
				pGCData->getCij(edge,dom,Cij);

				// get nodal pressure gradient
				pPPData->get_pw_Grad(I,dom,pw_grad_I);
				pPPData->get_pw_Grad(J,dom,pw_grad_J);
//				pPPData->get_pw_Grad(dom_counter,row_I,pw_grad_I);
//				pPPData->get_pw_Grad(dom_counter,row_J,pw_grad_J);

				// get nodal pressure
				pressure_I = pPPData->getPressure(I);
				pressure_J = pPPData->getPressure(J);

#ifdef _SEEKFORBUGS_
				if ( fabs(pressure_I) > 0.0 || fabs(pressure_J) > 0.0 ) check1=true;
#endif

				double nrc = (double)pGCData->getNumRC(theMesh,edge) + 1.0;
				double val = 0.5*(pressure_I + pressure_J)/nrc;
				for (i=0; i<dim; i++){
					pw_grad_I[i] +=  val*Cij[i];
					pw_grad_J[i] += -val*Cij[i];
				}

				// update nodal pressure gradient
				pPPData->set_pw_Grad(I,dom,pw_grad_I);
				pPPData->set_pw_Grad(J,dom,pw_grad_J);
//				pPPData->set_pw_Grad(dom_counter,row_I,pw_grad_I);
//				pPPData->set_pw_Grad(dom_counter,row_J,pw_grad_J);
			}
		}
		EIter_delete(eit);

#ifdef _SEEKFORBUGS_
		if (!check1) {
			char msg[256]; sprintf(msg,"Pressure field null for domain %d.\n",dom);
			throw Exception(__LINE__,__FILE__,msg);
		}
#endif

		// edge (boundary) contribution to pressure gradient (2D meshes)
		// =========================================================================
		if (dim==2){
			eit = M_edgeIter(theMesh);
			while ( (edge = EIter_next(eit)) ){
				// get edge flag
				int flag = GEN_tag(edge->getClassification());

				// get only edges on domain's boundaries
				//if ( flag>=1000 && flag<=2999 )
				if ( pGCData->belongsToBoundary(edge) )
					if ( pGCData->edgeBelongToDomain(edge,dom) ){
						Dij[0] = .0; Dij[1] = .0;
						pGCData->getDij(edge,dom,Dij);

						// get nodes I and J
						pEntity I = (pVertex)edge->get(0,0);
						pEntity J = (pVertex)edge->get(0,1);
						int row_I = pMData->getLocalNodeIDNumbering(EN_id(I));
						int row_J = pMData->getLocalNodeIDNumbering(EN_id(J));

						// todo: colocar este codigo em algum luar de forma que so seja feito uma unica vez.
						if (EN_id(edge->get(0,0)) > EN_id(edge->get(0,1))){
							std::swap(I,J);
						}

						// get nodal pressure
						pressure_I = pPPData->getPressure(I);
						pressure_J = pPPData->getPressure(J);

						// get nodal pressure gradient
						pPPData->get_pw_Grad(I,dom,pw_grad_I);
						pPPData->get_pw_Grad(J,dom,pw_grad_J);
//						pPPData->get_pw_Grad(dom_counter,row_I,pw_grad_I);
//						pPPData->get_pw_Grad(dom_counter,row_J,pw_grad_J);

						for (i=0; i<dim; i++){
							pw_grad_I[i] += ((5.*pressure_I + pressure_J)/6.0)*Dij[i];
							pw_grad_J[i] += ((pressure_I + 5.*pressure_J)/6.0)*Dij[i];
						}

						// update nodal pressure gradient
						pPPData->set_pw_Grad(I,dom,pw_grad_I);
						pPPData->set_pw_Grad(J,dom,pw_grad_J);
//						pPPData->set_pw_Grad(dom_counter,row_I,pw_grad_I);
//						pPPData->set_pw_Grad(dom_counter,row_J,pw_grad_J);
					}
			}
			EIter_delete(eit);
		}
		else{
			// faces contribution to pressure gradient (3D meshes)
			// =========================================================================
			FIter fit = M_faceIter(theMesh);
			while ( (face = FIter_next(fit)) ){
				if (pGCData->getDij(face,dom,Dij)){

					// get nodes I, J and K
					pEntity I = (pVertex)face->get(0,0);
					pEntity J = (pVertex)face->get(0,1);
					pEntity K = (pVertex)face->get(0,2);

					// get nodal pressure
					pressure_I = pPPData->getPressure(I);
					pressure_J = pPPData->getPressure(J);
					pressure_K = pPPData->getPressure(K);

					int row_I = pMData->getLocalNodeIDNumbering(EN_id(I));
					int row_J = pMData->getLocalNodeIDNumbering(EN_id(J));
					int row_K = pMData->getLocalNodeIDNumbering(EN_id(K));



#ifdef _SEEKFORBUGS_
					if ( fabs(pressure_I) > 0.0 || fabs(pressure_J) > 0.0 || fabs(pressure_K) > 0.0 ) check1=true;
#endif

					// get nodal gradient
					pPPData->get_pw_Grad(I,dom,pw_grad_I);
					pPPData->get_pw_Grad(J,dom,pw_grad_J);
					pPPData->get_pw_Grad(K,dom,pw_grad_K);
//					pPPData->get_pw_Grad(dom_counter,row_I,pw_grad_I);
//					pPPData->get_pw_Grad(dom_counter,row_J,pw_grad_J);
//					pPPData->get_pw_Grad(dom_counter,row_K,pw_grad_K);


					for (i=0; i<3; i++){
						pw_grad_I[i] += ((6.*pressure_I + pressure_J + pressure_K)/8.0)*Dij[i];
						pw_grad_J[i] += ((pressure_I + 6.*pressure_J + pressure_K)/8.0)*Dij[i];
						pw_grad_K[i] += ((pressure_I + pressure_J + 6.*pressure_K)/8.0)*Dij[i];
					}

					// update gradient
					pPPData->set_pw_Grad(I,dom,pw_grad_I);
					pPPData->set_pw_Grad(J,dom,pw_grad_J);
					pPPData->set_pw_Grad(K,dom,pw_grad_K);
//					pPPData->set_pw_Grad(dom_counter,row_I,pw_grad_I);
//					pPPData->set_pw_Grad(dom_counter,row_J,pw_grad_J);
//					pPPData->set_pw_Grad(dom_counter,row_K,pw_grad_K);
				}
			}
			FIter_delete(fit);
		}

		// weighting by domain's volume
		double vol;

		PetscReal norm;
		Vec gradVec;
		ierr = VecCreate(PETSC_COMM_WORLD,&gradVec);                         CHKERRQ(ierr);
		ierr = VecSetSizes(gradVec,PETSC_DECIDE,pMData->getNum_GNodes() );   CHKERRQ(ierr);
		ierr = VecSetFromOptions(gradVec);                                   CHKERRQ(ierr);
		ierr = VecZeroEntries(gradVec);                                      CHKERRQ(ierr);


		int row_I;
		VIter vit = M_vertexIter(theMesh);
		while ( (node = VIter_next(vit)) ){
			if ( pGCData->nodeBelongToDomain(node,dom) ){
				vol = pGCData->getVolume(node,dom);
				row_I = pMData->getLocalNodeIDNumbering(EN_id(node));
				pPPData->get_pw_Grad(node,dom,pw_grad_I);
				//pPPData->get_pw_Grad(dom_counter,row_I,pw_grad_I);
				for (i=0; i<dim; i++) {
					pw_grad_I[i] /= vol;
#ifdef _SEEKFORBUGS_
					if ( fabs(pw_grad_I[i]) > 0.0 ) check2 = true;
#endif
				}
				pPPData->set_pw_Grad(node,dom,pw_grad_I);
				//pPPData->set_pw_Grad(dom_counter,row_I,pw_grad_I);
				pw_grad_I.clear();
			}
		}
		VIter_delete(vit);

		/*
		 *  Calculate pressure gradient on nodes on partition boundaries.
		 *  Only for parallel.
		 */
		//pMData->unifyVectorsOnMeshNodes(pPPData->get_pw_Grad2,pPPData->set_pw_Grad2,pGCData,dom);
		//pMData->unifyVectorsOnMeshNodes(pPPData->get_pw_Grad,pPPData->set_pw_Grad,pGCData,dom);

#ifdef _SEEKFORBUGS_
		if (!check1) throw Exception(__LINE__,__FILE__,"Pressure field null!\n");
		if (!check2) throw Exception(__LINE__,__FILE__,"Gradient null!\n");
#endif

		dom_counter++;
	//}
	return 0;
}

int EBFV1_elliptic::resetPressureGrad(int dom, int dim){
	dblarray grad(dim,.0);
	//double pw_grad_I[3] = {.0,.0,.0};
	VIter vit = M_vertexIter(theMesh);
	while (pEntity node = VIter_next(vit)){
		pPPData->set_pw_Grad(node,dom,grad);
//		int row_I = pMData->getLocalNodeIDNumbering(EN_id(node));
//		pPPData->set_pw_Grad(dom,row_I,pw_grad_I);
	}
	VIter_delete(vit);
	return 0;
}
}
